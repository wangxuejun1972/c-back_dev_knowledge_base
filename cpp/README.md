## static作用

- **隐藏**

  当编译多个文件时, 所有未加static前缀的全局变量和函数都具有全局可见性, 加了static就会对其他源文件隐藏. 利用这一特性可以在不同的文件中定义同名函数和同名变量, 而不必担心命名冲突.

  对于函数来讲,static的作用仅限于隐藏, 对于变量,还有下面两个作用.

- **默认初始化为0**

  包括未初始化的全局静态变量和局部静态变量(存储在BSS段), 在BSS段中, 内存中所有的直接默认都是0x00, 某些时候这一特点可以减少程序员的工作量.

- **保持局部变量内容的持久**

  函数内的局部变量, 退出函数时就消失, 但静态局部变量虽然在函数内定义, 它的生存期为整个源程序, 其特点是只进行一次初始化且具有“记忆性”

  静态局部变量的生存期虽然为整个源程序,但其作用域仍与局部变量相同, 即只能在定义该变量的函数内使用该变量.退出函数后,尽管该变量还继续存在,但不能使用它

- **类中static的作用**

  表示属于一个类而不是属于此类的任何特定对象的变量和函数

  **静态数据成员**

  静态数据成员存在于任何对象之外, 对象中不包含任何与静态数据成员有关的数据. 使用作用域运算符直接访问静态成员, 可以使用类的对象,引用或指针来访问静态成员.

  必须在类的外部定义和初始化每个静态成员,一个静态数据成员只能定义一次,一旦被定义,就将一直存在于程序的整个生命周期中

  可以为静态成员提供const整数类型的类内初始值, 要求静态成员必须是字面值常量类型的constexpr,初始值必须是常量表达式. 该数据成员仍必须在类的定义体之外进行定义, 定义时,不再需要初始化.

  **静态成员函数**

  静态成员函数不与任何的对象相关联, 不具有this指针, 无法访问属于类对象的非静态数据成员,也无法访问非静态成员函数

  static成员函数不能被声明为const, 因为将成员函数声明为const说明该函数不会修改成员变量, 而static成员函数不属于任何对象. static成员函数也不能声明为虚函数, volatie

## const的作用，const放在函数前后的区别

- 修饰变量

  常量在定义后就不能被修改, 所以定义时必须初始化

- 修饰指针

  指向const的指针: 不能修改所指内容的值

  指针常量: 不能改变指针的指向

- 修饰函数参数与返回值

  尽量使用const修饰引用与指针, 除非此参数确实需要在函数内修改, 可以用非常量初始化一个底层const对象, 但反过来不行

- 在类中的作用

  **修饰成员函数**

  const成员函数不能修改成员变量的值.

  **const数据成员**

  常量数据成员必须在构造函数的成员初始化列表中进行初始化

默认状态下,const对象仅在文件内有效, 如果想在多个文件之间共享const对象,必须在变量定义之前添加`extern`关键字

## const关键字与宏定义的区别是什么？

- 编译器处理方式不同，宏定义是在预处理阶段展开，进行简单的字符串替换；const关键字是在编译时
- 类型和安全检查不同，宏定义没有类型，不作任何安全检查；const常量有具体的类型，在编译时会执行类型检查

## 函数重载

- 函数名称必须相同
- 参数列表必须不同(参数的类型,个数,顺序不同)
- 参数的返回类型可以相同也可以不同
- 仅仅返回类型不同不足以成为函数重载

对于非引用传参，形参是否const是等价的。但是当使用引用传参时，有无const是不同的。使用指针传参时，指向const对象的指针和指向非const对象的指针做形参的函数是不同的

在类中，由于隐含的this形参的存在，const版本的成员函数使得作为形参的this指针的类型变为指向const对象的指针

## 引用与指针的区别是什么？

- 引用不能为空, 声明引用的同时必须进行初始化; 而指针可以为空值, 可以在任何时候被初始化
- 引用一经初始化, 不能再改变指向; 指针则可以在任何时候指向另一个对象
- 指针存放的是变量的地址，表示指向这个变量
- 不能在函数内部返回new分配的堆空间变量的引用。如果返回的引用只是作为一个临时变量出现,而没有被赋
  予一个实际的变量,那么该引用所在的空间就无法释放,会造成内存泄漏。
- 使用&取一个引用的地址时,其值为所引用变量的地址; 而对指针使用&, 取的是指针变量的地址

## malloc的底层实现是怎样的？free是怎么回收内存的？

- malloc ()函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。 调用 malloc()函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。 调用 free 函数时，它将用户释放的内存块连接到空闲链表上。 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc()函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。
- free() 不会改变指针变量本身的值，调用 free() 后它仍然会指向相同的内存空间，但是此时该内存已无效，不能被使用。

## new/delete与malloc/free的区别是什么？

- malloc/free是C/C++的标准库函数，new/delete是C++的运算符
- new能够自动分配空间大小，同时还对空间进行初始化；malloc需要传入参数，不能初始化
- new是类型安全的,而malloc不是
- new/delete能对对象进行构造和析构函数的调用，而malloc/free不行
- malloc/free需要库文件支持, new/delete不需要

## inline函数与带参数的宏定义的区别？

- 宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的,编译器将使用函数的定义体来替代函数调用语句,这种替代行为发生在编译阶段而非程序运行阶段
- 宏定义不可调试，内联函数是可以调试的
- 在调用内联函数时，编译器会进行类型安全检查或自动类型转换，如果正确，内联函数的代码就会直接替换函数调用语句；宏定义不会进行类型安全检查和自动类型转换，无法操作类的私有数据成员

## C++内存布局分为几个区域，各自具备什么特点？

- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值，向下增长
- 堆区：一般由程序员分配释放，若程序员不释放，结束时可能由系统回收，向上增长
- 全局/静态区：存放全局变量和静态变量，在程序编译时分配. 包括DATA段(全局初始化区)与BSS段(全局未初始化区). 其中初始化的全局变量和静态变量存放在DATA段, 未初始化的全局变量的未初始化的静态变量存放在BSS段.程序结束后由系统释放
- 文字常量区：存放常量字符串, 程序结束后由系统释放
- 程序代码区：存放函数体(普通函数、类的成员函数)的二进制代码

## 堆和栈的区别

1. ##### 申请方式

   **stack**: 系统自动分配,速度快

   **heap**: 通过调用`malloc`函数或`new`表达式申请,速度相对较慢,且容易产生内存碎片

2. ##### 系统响应

   **stack**: 只要系统剩余空间大于申请空间就能申请,否则报错,栈溢出

   **heap**: 操作系统中有一个记录空闲内存地址的链表, 当系统收到程序的申请时,会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该节点从空闲节点中删除,并将该节点的空间分配给程序.另外,对于大多数系统,首地址处会记录这块内存空间中本次分配的大小, 这样delete表达式才能正确的释放本内存空间.

   另外由于找到的堆结点的大小不一定正好等于申请的大小,系统会自动的将多余的那部分重新放入空闲链表中

3. ##### 申请大小的限制

   **stack**: 由高地址向低地址扩展, 是一块连续的内存区域. 栈顶的地址和栈的最大容量是系统预先规定好的. 在Linux下,默认栈空间大小是8M, 如果申请的空间超过栈的剩余空间时, 将提示overflow.

   **heap**: 由低地址向高地址扩展, 是不连续的内存区域. 这是由于系统是用链表来存储空闲内存地址. 堆获得的空间受限于系统中有效的虚拟内存, 比较灵活

## 拷贝构造函数在以下三种情况会自动调用

当把一个已经存在的对象赋值给另一个新的对象时

当实参和形参都是对象，进行形参和实参的结合时

当函数的返回值是对象，函数调用完成返回时

## 什么是浅拷贝, 什么是深拷贝?

- 浅拷贝：对指针变量直接传递地址，造成两个对象的指针都指向了同一块内存，当两个对象释放时，对同一块内存执行了delete操作
- 深拷贝：先为指针变量开辟空间，然后再进行复制，两个对象都有独立的堆空间

## C++强制转换

- static_cast

  用于基本数据类型之间的转换

  把void指针转换成目标类型的指针

  把任意类型表达式转换成void类型

  用于类层次结构中基类和派生类之间指针或引用的转换, 把派生类的指针或引用转换成基类的指针或引用(上行转换)是安全的; 把基类指针或引用转换成子类指针或引用(下行转换),由于没有动态类型检查,所以是不安全的.

- const_cast

  该运算符用来修改类型的const属性。常量指针被转化成非常量指针,并且仍然指向原来的对象;常量引用被转换
  成非常量引用,并且仍然指向原来的对象;常量对象被转换成非常量对象。

- dynamic_cast

  该运算符主要用于基类和派生类间的转换,尤其是向下转型的用法中。

- reinterpret_cast

  该运算符可以用来处理无关类型之间的转换,即用在任意指针(或引用)类型之间的转换,以及指针与足够大的整
  数类型之间的转换。由此可以看出,reinterpret_cast的效果很强大,但错误的使用reinterpret_cast很容易导致程
  序的不安全,只有将转换后的类型值转换回到其原始类型,这样才是正确使用reinterpret_cast方式。

### 链接指示: extern "C"

被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的

`extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

```C++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

## volatile

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

## 自增运算符的前置形式和后置形式有什么区别?返回值类型分别是什么？

- ##### 前置形式返回的是对象本身，返回类型是引用；

- ##### 后置形式返回的是对象变化之前的值，需要一个临时对象存储对象变化之前的值，返回类型为一个对象。

```C++
//前置形式，增加然后取回值
UPInt& UPInt::operator++() {
    *this += 1;
    return *this;
}
```
```C++
//后置形式，取回然后增加
//后置形式在其参数中多加一个int，该int不是要传递参数，只是为了前置形式进行区分
const UPInt UPInt::operator++(int) {
    UPInt oldValue = *this;
    ++*this;
    return oldValue;
}
```

## [继承与派生](继承与派生.md)

## [虚函数与多态](虚函数与多态.md)


## gcc编译的步骤

1. 预处理:预处理器将对源文件中的宏进行展开,对包含的头文件(#include)和宏定义(#define、#ifdef等)进行处理, `gcc -E test.c -o test.i`
2. 编译:检查代码规范性、语法错误等,在检查无误后把代码翻译成汇编语言,`gcc -S test.i -o test.s`
3. 汇编:as将汇编文件编译成机器码,`as test.s -o test.o`
4. 链接:将目标文件和外部符号进行连接,得到一个可执行二进制文件,`gcc test.o -o test`

## 静态库与动态库

##### 静态库

静态库是目标文件.a 的归档文件(格式为 libname.a)。对于静态链接库而言在链接阶段，会将汇编生成的「目标文件.o」与引用到的库一起链接打包到可执行文件中.

缺点优点:

- 静态链接库对函数库的链接是放在编译时期完成的。程序在运行时与函数库就没有了任何的联系。
- 它比较浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
- 静态库对程序的更新和发布也会带来麻烦。如果静态库更新了，所有使用它的应用程序都需要重新编译、部署、发布给用户。

优点在于移植的时候只需要移动这一个文件，缺点在于文件体积非常大，为了解决这样的问题，就有了动态链接库

创建静态库

```shell
$ gcc -c add.c //编译 add.c 源文件生成 add.o 目标文件
$ ar crsv libadd.a add.o //对目标文件*.o 进行归档,生成 lib*.a,
//将库文件 libadd.a 拷贝到/lib 或者/usr/lib 下(系统默认搜索库路径)

$ gcc -o main main.c –ladd //-ladd 表示链接库文件 libadd.a
```

##### 动态库

动态库(格式为 libname.so[. 主版本号 . 次版本号 . 发行号 ])。在程序编译时并不会被链接到目标代码中,而是在程序运行时才被载入。

- 不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，可以实现进程之间的资源共享。（因此动态库也称为共享库）规避了空间浪费问题。
- 动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦。用户只需要更新动态库即可将一些程序升级变得简单，增量更新。

优点在于编译程序的时候不会将对应的库文件全部打包在生成的程序中，而是保留了到对应库的链接，缺点就是移植的时候如果只移动了对应的程序没有安装相关的库的话，就会出现错误

 创建动态库

```shell
$ gcc -fPIC -shared -o libadd.so add.c
//在运行 main 前,需要注册动态库的路径。将库文件拷贝到/lib 或者/usr/lib 下(系统默认搜索库路径)。
gcc -o main main.c –ladd //-ladd 表示链接库文件 libadd.so
```

## 查看内核版本和发行版本

`uname -a`

`cat /etc/issue`

## 系统调用与库函数的区别，什么系统调用会耗时长

系统调用是受控的内核入口，借助这一机制，进程可以请求内核以自己的名义去执行某些动作。以API的形式，内核提供一系列服务供程序访问。这包括创建新进程、执行I/O，以及为进程间通信创建管道等。系统调用将处理器从用户态切换到内核态，以便CPU访问受到保护的内核内存。系统调用提供了用户程序与操作系统之间的接口。

库函数用于提供用户态服务。它可能调用封装了一个或几个不同的系统调用（printf调用write），也可能直接提供用户态服务（atoi不调用任何系统调用）。

## 进程和线程的区别

**调度**：进程是资源分配的最小单位，线程是CPU调度的最小单位，每个进程都有一个main线程 

**地址空间和其他资源**(如打开的文件)：进程的地址空间之间相互独立，同一进程的个线程间共享进程的资源

**系统开销**：创建和撤销进程时，系统都要为之分配和回收资源，如内存空间、I/O设备等。  切换进程时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置。线程切换时只需要保存和设置少量寄存器内容， 减小了上下文切换的开销 。另外，由于同一进程内的多个线程共享进程的地址空间(堆、代码、数据、文件描述符、信号等)，因此线程之间的同步与通信比较容易实现，甚至无需操作系统的干预

**通信**：进程间通信需要借助操作系统，而线程间可以直接读写进程数据段(如全局变量)来进行通信

一个进程挂掉了不会影响其他进程，而线程挂掉了会影响其他线程 

线程执行开销小，占用的CPU少，线程之间的切换快，但不利于资源的管理和保护；而进程正相反。

## 线程私有和共享那些资源？进程私有和共享那些资源？

线程私有：线程控制表、线程id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno变量                   

共享：堆，地址空间，全局变量，静态变量 

进程私有：地址空间，堆，全局变量，栈，寄存器 

共享：代码段，公共数据，进程目录，文件描述符

## 进程

#### fork() 函数创建子进程的过程

使用fork 函数得到的子进程是父进程的一个复制品，它从父进程继承了**进程的地址空间，包括进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设定、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端，而子进程所独有的只有它的进程号、资源使用和计时器等**。通过这种复制方式创建出子进程后，原有进程和子进程都从函数fork 返回，各自继续往下运行，但是原进程的fork 返回值与子进程的fork 返回值不同，在原进程中，fork 返回子进程的pid,而在子进程中，fork 返回0,如果fork 返回负值，表示创建子进程失败。

#### 父进程打开一个文件，然后fork(),父子进程共享同一个文件描述符，fork内部使用的dup；如果先fork，父子进程再分别open文件，则它们不共享文件描述符

#### 子进程怎么才能不继承父进程的句柄

exec函数族, `int execl(const char *path, const char *arg, ...)`,exec 函数是用exec 的第一个参数指定的程序覆盖现有进程空间（也就是说执行exec 族函数之后，它后面的所有代码不在执行）

- 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构
- 映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。
- 映射共享区域
- 设置程序计数器(PC)

#### 孤儿进程

父进程先于子进程退出，则子进程成为孤儿进程，此时将自动被PID 为1 的进程（即init）接管。孤儿进程退出后，它的清理工作有祖先进程init 自动处理。但在init 进程清理子进程之前，它一直消耗系统的资源，所以要尽量避免

#### 僵尸进程

如果子进程先退出，系统不会自动清理掉子进程的环境，而必须由父进程调用wait 或waitpid 函数来完成清理工作，如果父进程不做清理工作，则已经退出的子进程将成为僵尸进程,在系统中如果存在的僵尸进程过多，将会影响系统的性能，所以必须对僵尸进程进行处理

#### 守护进程

它是没有控制终端与之相连的进程。它独立与控制终端、会话周期的执行某种任务。守护进程脱离终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的任何终端信息所打断。在linux 中，每一个用户与系统进行交流的界面称为终端，每一个从此终端开始运行的进程都会依赖这个终端，这个终端就称为这些进程的控制终端。当控制终端被关闭时，相应的进程都会自动关闭。但是守护进程却能突破这种限制，它被执行开始运转，直到整个系统关闭时才退出。末尾的字母d 通常就是指daemon。

- 守护进程最重要的特性是后台运行。
- 守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符、控制终端、会话和进程组、工作目录已经文件创建掩码等。这些环境通常是守护进程从父进程那里继承下来的。

创建守护进程

- 调用fork 产生一个子进程，同时父进程退出。

- 在子进程中创建新会话

  调用setsid 函数会创建一个新的会话并自任该会话的组长，调用setsid 函数有下面3 个作用：让进程摆脱原会话的控制，让进程摆脱原进程组的控制，让进程摆脱原控制终端的控制

- 改变当前目录为根目录(可以省略)

- 重设文件权限掩码，`umask(0)`

- 关闭所有不需要的文件描述符

#### 进程的终止有5 种方式

- main 函数的自然返回
- 调用exit 函数
- 调用_exit 函数
- 调用abort 函数
- 接收到能导致进程终止的信号ctrl+c  SIGINT， ctrl+\   SIGQUIT

前3 种方式为正常的终止，后2 种为非正常终止。

#### 如何监控进程异常退出

`pid_t wait(int *wstatus);`父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait()函数会释放子进程资源并返回。如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。参数 status 用来保存被收集的子进程退出时的一些状态

`WIFEXITED(wstatus)`如果子进程正常退出返回true

### 进程间通信

#### 管道

1. 标准流管道

   函数`popen()`：允许一个程序将另一个程序作为新进程来启动，并可以传递数据给它或者通过它接收数据。command 字符串是要运行的程序名。open_mode 必须是“r”或“w”。如果open_mode 是“r”，被调用程序的输出就可以被调用程序(popen)使用，调用程序利用popen 函数返回的FILE*文件流指针，就可以通过常用的stdio 库函数（如fread）来读取被调用程序的输出；如果open_mode 是“w”，调用程序(popen)就可以用fwrite 向被调用程序发送数据，而被调用程序可以在自己的标准输入上读取这些数据。
   函数`pclose()`：用popen 启动的进程结束时，我们可以用pclose 函数关闭与之关联的文件流。

2. 无名管道(PIPE)

   特点：

   - 只能在**亲缘关系**进程间通信
   - 半双工（固定的读端和固定的写端）
   - 他是特殊的文件，可以用read、write 等，只能在内存中

   `int pipe(int fds[2])`

   管道在程序中用一对文件描述符表示，其中一个文件描述符有可读属性，一个有可写的属性。fds[0]是读，fds[1]是写。函数pipe 用于创建一个无名管道，如果成功，fds[0]存放可读的文件描述符，fds[1]存放可写文件描述符,并且函数返回0，否则返回-1。

3. 命名管道(FIFO)

   可以实现不相关进程间的通信

   函数：创建`int mkfifo(const char *pathname, mode_t mode)`   删除`int unlink(const char *pathname)`

#### 共享内存

System V 共享内存机制：`shmget` `shmat` `shmdt` `shmctl`

共享内存允许一个或多个进程通过同时出现在它们的虚拟地址空间的内存进行通信，而这块虚拟内存的页面被每个共享进程的页表条目所引用，同时并不需要在所有进程的虚拟内存都有相同的地址。

进程结束后共享内存不会消失

##### 如何提高共享内存的使用效率

`int shmget(key_t key, size_t size, int shmflg)`

shmflg： `SHM_HUGETLB`，`SHM_HUGE_2MB`降低TLB miss

##### mmap实现的共享内存和System V 共享内存有什么区别

mmap是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间进行映射。而对于shm而言，shm每个进程最终会映射到同一块物理内存。shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大。

当物理内存不足，System V共享内存会把部分物理页回写到swap分区，而mmap会回写到文件

当机器重启，因为mmap把文件保存在磁盘上，这个文件还保存了操作系统同步的映像，所以mmap不会丢失，但是shmget就会丢失

#### 信号量

System V 信号量，在内核中维护，可用于进程或线程间的同步，常用于进程的同步。

通过pv操作实现的

#### 消息队列

消息队列与FIFO 很相似，都是一个队列结构，都可以有多个进程往队列里面写信息，多个进程从队列中读取信息。但FIFO 需要读、写的两端事先都打开，才能够开始信息传递工作。而消息队列可以事先往队列中写信息，需要时再打开读取信息。但是，消息队列先打开读，仍然会阻塞，因为此时没有消息可读

`int msgget(key_t key, int msgflg)`

`ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)`

`int msgctl(int msqid, int cmd, struct msqid_ds *buf)`

#### 信号

它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则系统将采用默认的方式处理该信号，即终止进程的执行

SIGKILL(9号信号)不能被忽略，任何进程收到9号信号都要终止

##### 信号的产生方式

信号的生成来自内核，让内核生成信号的请求来自3 个地方：

- 用户：用户能够通过输入CTRL+c、Ctrl+\，或者是终端驱动程序分配给信号控制字符的其他任何键来请求内核产生信号；
- 内核：当进程执行出错时，内核会给进程发送一个信号，例如非法段存取(内存访问违规)、浮点数溢出等；
- 进程：一个进程可以通过系统调用kill 给另一个进程发送信号，一个进程可以通过信号和另外一个进程进行通信。

## 线程

|        | 创建             | 退出           | 等待           |
| ------ | ---------------- | -------------- | -------------- |
| 多进程 | fork()           | exit()         | wait()         |
| 多线程 | pthread_create() | pthread_exit() | pthread_join() |

#### 清理函数会被得到执行的3种情况 

`pthread_cleanup_push()/pthread_cleanup_pop()`

线程被取消
线程通过pthread_exit退出
pthread_cleanup_pop(1)

#### 线程互斥

`int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr)`

`int pthread_mutex_lock(pthread_mutex_t *mutex)`
`int pthread_mutex_unlock(pthread_mutex_t *mutex)`

`int pthread_mutex_destroy(pthread_mutex_t *mutex)`

#### 线程同步

条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待条件变量的条件成立而挂起；另一个线程使条件成立（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。

`int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);`

`int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);`

`int pthread_cond_destroy(pthread_cond_t *cond);`

`int pthread_cond_signal(pthread_cond_t *cond);`

做pthread_cond_wait 之前，往往要用pthread_mutex_lock 进行加锁，而调用pthread_cond_wait 函数会将锁解开，然后将线程挂起阻塞。直到条件被pthread_cond_signal 激发，再将锁状态恢复为锁定状态，最后再用pthread_mutex_unlock 进行解锁

#### 死锁

多个进程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进

##### 死锁产生的原因

系统资源的竞争

进程推进顺序非法

##### 死锁产生的必要条件

必须满足一下4个条件

- 互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待
- 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放
- 请求和保持条件：又称为部分分配条件。进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源
- 循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

##### 死锁处理策略

- 预防死锁：设置某些限制条件，破坏产生死锁的4个必要条件中的1个或几个
- 避免死锁：在资源的动态分配过程中，用某种方法阻止系统进入不安全状态。银行家算法
- 死锁的检测与解除：允许进程在允许过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。死锁的检测可利用资源分配图来描述。死锁解除主要有资源剥夺法、撤销进程法、进程回退法。